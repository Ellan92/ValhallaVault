@page "/QuestionPage/{chosenSegment:int}"
@using ValhallaVault.Models
@using ValhallaVault.Models.ViewModels
@using ValhallaVault.Data
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Identity
@inject ValhallaVault.Managers.QuestionManager questionManager
@inject NavigationManager Navigation
@inject ValhallaVault.Managers.GenericManager<SegmentModel> genericManager
@inject ValhallaVault.Managers.GenericManager<ResultModel> genericResultManager
@inject ValhallaVault.Managers.GenericManager<ApplicationUser> genericUserManager
@inject ValhallaVault.Managers.SubcategoryManager subcategoryManager
@inject AuthenticationStateProvider AuthenticationProvider
@inject ValhallaVault.Managers.UserManager usermanager
@inject ValhallaVault.Managers.Factory factory
@inject SignInManager<ApplicationUser> SignInManager
@rendermode InteractiveServer

<style>
    a.pointer 
    {
        cursor: pointer; /* Ange pekare som muspekare */
    }

    .green-text
    {
        color: green;
        opacity: .7;
    }

    .red-text {
        color: red;
        opacity: .7;
    }
</style>
<div class="container">
    <div class="row">
        <div class="col-md-12">
            <h3 class="mt-3">Frågor för denna subkategori</h3>
            <p><stronger>Återstående frågor: @Questions.Count </stronger></p>
            <!-- Observarade frågor -->
            @if (Questions != null && Questions.Any())
            {
                @foreach (var question in Questions)
                {
                    <div class="card mt-3">
                        <div class="card-body">
                            <h4 class="card-title">@question.Question</h4>
                            <ul class="list-group"> <!-- list-group för alla frågor, vare sig de är besvarade eller inte. -->
                                @if (question.Options != null && question.Options.Count > 0 && question.IsAnswered==false)
                                {
                                    @foreach (var option in question.Options)
                                    {
                                        <li class="list-group-item">
                                            <!-- När användaren klickar på ett option, skicka med både question och option -->
                                            <a class="pointer" @onclick="(() => HandleOptionClick(question, option))">@option</a>
                                        </li>
                                    }
                                }
                            </ul>
                        </div>
                    </div>
                }
            }

            @if (FeedbackQuestion != null && FeedbackQuestion.Any() && ResultIsVisible == true)
            {
                <div class="container mt-3">
                    <div class="card">
                        <div class="card-body">
                            <h5 class="card-title">Resultat</h5>
                            <div>
                                <h2>Frågor</h2>
                                <ol>
                                @foreach (var question in FeedbackQuestion)
                                {
                                    <li>@question</li>
                                }
                                </ol>

                                <h2>Dina svar</h2>
                                <ol>
                                @foreach (var answer in FeedbackAnswer)
                                {
                                    <li>@answer</li>
                                }
                                </ol>

                                <h2>Facit</h2>
                                <ol>
                                @foreach (var correct in FeedbackCorrected)
                                {
                                    <li>@correct</li>
                                }
                                </ol>
                            </div>
                        </div>
                    </div>
                </div>
            }

            <button @onclick="SubmitQuiz">Lämna in</button>
            @if (MessageIsVisible==true)
            {
                <h6>Vänligen svara på alla frågor innan du lämnar in.</h6>
            }
            <a href="@($"SegmentPage/{chosenSegment}")" class="btn btn-primary mt-3">Tillbaka</a>
        </div>
    </div>
</div>



@code {
    [Parameter]
    public int chosenSegment { get; set; }

    public int index; 

    private bool MessageIsVisible = false;

    private bool ResultIsVisible = false;

    public string? UserName { get; set; }

    public SegmentModel? ChosenSegment { get; set; }

    public List<SubcategoryModel> Subcategories { get; set; } = new();

    public int NumberOfQuestions = 0;

    public List<QuestionViewModel> Questions { get; set; } = new();

    public List<QuestionViewModel> AnsweredQuestions { get; set; } = new();

    public List<UserResult> UserResultList { get; set; } = new();

    // strängar för att displaya resultat
    public List<String> FeedbackQuestion { get; set; } = new();

    public List<String> FeedbackAnswer { get; set; } = new();

    public List<String> FeedbackCorrected { get; set; } = new();

    private ApplicationUser? signedIn; // representerar den inloggade användaren
    private AuthenticationState? State; // representerar autentiseringsstatusen för användaren



    protected override async Task OnParametersSetAsync()
    {
        if (Questions.Count == 0)
        {
            await LoadQuestionsAsync();
        }
    }


    private async Task LoadQuestionsAsync()
    {
        Questions.Clear();

        var segment = await genericManager.GetByIdAsync(chosenSegment);
        if (segment != null)
        {
            ChosenSegment = segment;

            var allSubcategories = await subcategoryManager.GetSubcategoriesBySegmentIdAsync(chosenSegment);
            if (allSubcategories != null)
            {
                foreach (var subcategory in allSubcategories)
                {
                    Subcategories.Add(subcategory);
                }

                if (Subcategories.Count > 0)
                {
                    foreach (var sc in Subcategories)
                    {
                        var questionList = await questionManager.GetQuestionsBySubcategoryIdAsync(sc.Id);
                        if (questionList != null && questionList.Count > 0)
                        {
                            foreach (var question in questionList)
                            {
                                QuestionViewModel viewmodelQuestion = factory.CreateQuestionViewModel(question);
                                if (!Questions.Contains(viewmodelQuestion))
                                {
                                    Questions.Add(viewmodelQuestion);
                                }
                            }
                        }
                    }
                }

                NumberOfQuestions = Questions.Count;
            }
        }
    }

    private void SubmitQuiz()
    {
        int answeredQuestions = AnsweredQuestions.Count;
        if (answeredQuestions < NumberOfQuestions)
        {
            MessageIsVisible = true; // visa meddelandet om att alla frågor måste besvaras. 
        }
        else if (answeredQuestions == NumberOfQuestions)
        {
            Questions.Clear();
            ResultIsVisible = true;
        }

    }


    private async Task HandleOptionClick(QuestionViewModel question, string chosenOption) // Metod för att utvärdera valt svarsalternativ
    {
        question.IsAnswered = true;
        Questions.Remove(question);
        AnsweredQuestions.Add(question);

        var solutionToQuestion = await questionManager.GetSolutionByQuestionId(question.QuestionId);  // Hämta rätt svar
        if (solutionToQuestion!=null)
        {
            string solution = solutionToQuestion.CorrectAnswer;  // Omvandla rätt svar till en sträng
            bool isCorrectAnswer = chosenOption.Equals(solutionToQuestion.CorrectAnswer);  // Jämför strängen med användarens svar

            ResultModel newResult = null;   // Skapa ett resultat
            if (isCorrectAnswer)
            {
                question.IsCorrectAnswer = true;
                QuestionModel questionModel = factory.CreateQuestionModel(question);   // Omvandla questionviewmodel till vanlig model
                newResult = factory.CreateCorrectResult(chosenOption, true, question.QuestionId);
                ResultViewModel resultviewmodel = factory.CreateResultViewModel(newResult);
            
                // Skapa resultat-strängarna 
                FeedbackQuestion.Add($"\nFråga: {question.Question}");
                FeedbackAnswer.Add($"\nDitt svar: {chosenOption}");
                FeedbackCorrected.Add($"\nRätt svar: {solution}");
            }

            else if (!isCorrectAnswer)
            {
                question.IsCorrectAnswer = false;
                QuestionModel questionModel = factory.CreateQuestionModel(question);
                newResult = factory.CreateWrongResult(chosenOption, false, question.QuestionId);  // Skapa ett felaktigt resultat med hjälp av Factory
                ResultViewModel resultviewmodel = factory.CreateResultViewModel(newResult);
               
                // Skapa resultat-strängarna 
                FeedbackQuestion.Add($"\nFråga: {question.Question}");
                FeedbackAnswer.Add($"\nDitt svar: {chosenOption}");
                FeedbackCorrected.Add($"\nRätt svar: {solution}");


            }
            await genericResultManager.CompleteAsync();

            // Hämta den inloggade usern för att kunna koppla resultatet till rätt användare
            State = await AuthenticationProvider.GetAuthenticationStateAsync();
            var user = State.User;
            UserName = user.Identity.Name;
            var findtheUser = await usermanager.GetUserByNameAsync(UserName);

            // Skapa ett UserResult
            UserResult userresult;
            if (findtheUser != null)
            {
                // Skapa ett UserResult med hjälp av Factory
                userresult = factory.CreateUserResult(findtheUser, newResult);

                if (userresult != null && !UserResultList.Contains(userresult))
                {
                        UserResultList.Add(userresult);
                        findtheUser.UserResults.Add(userresult);
                        await genericUserManager.CompleteAsync();
                }

            }
      
        }
    }
}