@page "/QuestionPage/{chosenSegment:int}"
@using ValhallaVault.Models
@using ValhallaVault.Data
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Identity
@inject ValhallaVault.Managers.QuestionManager questionManager
@inject NavigationManager Navigation
@inject ValhallaVault.Managers.GenericManager<SegmentModel> genericManager
@inject ValhallaVault.Managers.GenericManager<ResultModel> genericResultManager
@inject ValhallaVault.Managers.GenericManager<ApplicationUser> genericUserManager
@inject ValhallaVault.Managers.SubcategoryManager subcategoryManager
@inject AuthenticationStateProvider AuthenticationProvider
@inject ValhallaVault.Managers.UserManager usermanager
@inject ValhallaVault.Managers.Factory factory
@inject SignInManager<ApplicationUser> SignInManager
@rendermode InteractiveServer

<style>
    a.pointer 
    {
        cursor: pointer; /* Ange pekare som muspekare */
    }

    .green-text
    {
        color: green;
    }

    .red-text {
        color: red;
    }

</style>

<div class="container">
    <div class="row">
        <div class="col-md-12">
            <h3 class="mt-3">Frågor för denna subkategori</h3>
            <p><stronger>Återstående frågor: @Questions.Count </stronger></p>
            <!--Visa besvarande frågor först, om det finns några-->
            @if (InCorrectlyAnsweredQuestions!= null && InCorrectlyAnsweredQuestions.Any())
            {
                @foreach (var question in InCorrectlyAnsweredQuestions)
                {
                    <div class="card mt-3">
                        <div class="card-body">
                            <h6 class="card-title mt-3 red-text" style="opacity: 0.7;">@question.Question</h6>
                            <ul class="list-group mt-3 red-text" style="opacity: 0.7;">

                                @if (question.Options != null && question.Options.Count > 0)
                                {
                                    @foreach (var option in question.Options)
                                    {
                                        <li class="list-group-item mt-3 red-text" style="opacity: 0.7;">
                                           @option
                                        </li>
                                    }
                                }
                            </ul>
                        </div>
                    </div>
                }
            }

            @if (CorrectlyAnsweredQuestions != null && CorrectlyAnsweredQuestions.Any())
            {
                @foreach (var question in CorrectlyAnsweredQuestions)
                {
                    <div class="card mt-3">
                        <div class="card-body">
                            <h6 class="card-title mt-3 green-text" style="opacity: 0.7;">@question.Question</h6>
                            <ul class="list-group mt-3 green-text" style="opacity: 0.7;">

                                @if (question.Options != null && question.Options.Count > 0)
                                {
                                    @foreach (var option in question.Options)
                                    {
                                        <li class="list-group-item mt-3 green-text" style="opacity: 0.7;">
                                            @option
                                        </li>
                                    }
                                }
                            </ul>
                        </div>
                    </div>
                }
            }

            <!-- Visa frågorna om det finns några -->
            @if (Questions != null && Questions.Any())
            {
                @foreach (var question in Questions)
                {
                    <div class="card mt-3">
                        <div class="card-body">
                            <h4 class="card-title">@question.Question</h4>
                            <ul class="list-group">
                              
                                @if (question.Options != null && question.Options.Count > 0)
                                {
                                    @foreach (var option in question.Options)
                                    {
                                        <li class="list-group-item">
                                            <!-- När användaren klickar på ett option, skicka med både question och option -->
                                            <a class="pointer" @onclick="(() => HandleOptionClick(question, option))">@option</a>
                                        </li>
                                    }
                                }
                            </ul>
                        </div>
                    </div>
                }
            }

            <a href="@($"SegmentPage/{chosenSegment}")" class="btn btn-primary mt-3">Tillbaka</a>

        </div>
    </div>
</div>

@code {
    [Parameter]
    public int chosenSegment { get; set; }

    public string? UserName { get; set; }

    public SegmentModel? ChosenSegment { get; set; }

    public List<SubcategoryModel> Subcategories { get; set; } = new();

    public int Points = 0;

    // Listor måste vara public för att kunna ska nås av andra komponenter. 

    public List<QuestionModel> Questions { get; set; } = new();

    public List<QuestionModel> CorrectlyAnsweredQuestions { get; set; } = new();

    public List<QuestionModel> InCorrectlyAnsweredQuestions { get; set; } = new();

    private ApplicationUser? signedIn; // representerar den inloggade användaren
    private AuthenticationState? State; // representerar autentiseringsstatusen för användaren


    protected override async Task OnInitializedAsync()
    {
        var segment = await genericManager.GetByIdAsync(chosenSegment);
        if (segment != null)
        {
            segment = ChosenSegment;

            var allSubcategories = await subcategoryManager.GetSubcategoriesBySegmentIdAsync(chosenSegment);
            if (allSubcategories != null)
            {
                foreach (var subcategory in allSubcategories)
                {
                    // skapa listan med subkategorier
                    Subcategories.Add(subcategory);

                }
                if (Subcategories.Count>0)
                {
                    // Hämta alla frågor för varje subkategori
                    foreach (var sc in Subcategories)
                    {
                        // en lista med frågor per subkategori 
                        var questionList = await questionManager.GetQuestionsBySubcategoryIdAsync(sc.Id);

                        // lägg till alla frågor till en och samma lista (Questions)
                        if (questionList!=null && questionList.Count>0)
                        {
                            foreach (var question in questionList)
                            {
                                Questions.Add(question);
                            }
                        }
                    }
                }
            }
        }
    }

    // Metod för att utvärdera valt svarsalternativ
    private async Task HandleOptionClick(QuestionModel question, string chosenOption)
    {
        // Ta bort frågan från listan när användaren har svarat 
        Questions.Remove(question);
        StateHasChanged();   // Signalerar att komponenten har uppdaterats och att UI:et behöver uppdateras

        var solutionToQuestion = await questionManager.GetSolutionByQuestionId(question.Id);
        if (solutionToQuestion!=null)
        {
            // Hämta korrekt svar från solution
            string solution = solutionToQuestion.CorrectAnswer;
            bool isCorrectAnswer = chosenOption.Equals(solutionToQuestion.CorrectAnswer);

            // Skapa ett resultat
            ResultModel newResult = null;
            if (isCorrectAnswer)
            {
                CorrectlyAnsweredQuestions.Add(question);
                StateHasChanged();
                Points++; // lägg till ett poäng
                          // Skapa ett korrekt resultat med hjälp av Factory
                newResult = factory.CreateCorrectResult(chosenOption, true, question, question.Id);
            }
            else
            {
                InCorrectlyAnsweredQuestions.Add(question);
                StateHasChanged();
                if (Points>0)
                {
                    Points--; // dra bara bort poäng om användaren har minst 1 poäng. 
                }
                // Skapa ett felaktigt resultat med hjälp av ResultFactory
                newResult = factory.CreateWrongResult(chosenOption, false, question, question.Id);
            }

            // Spara resultatet i databasen
            await genericResultManager.AddAsync(newResult);
            await genericResultManager.CompleteAsync();

            // Hämta den inloggade usern för att kunna koppla resultatet till rätt användare
            State = await AuthenticationProvider.GetAuthenticationStateAsync();
            var user = State.User;
            UserName = user.Identity.Name;
            var findtheUser = await usermanager.GetUserByNameAsync(UserName);

            // Skapa ett UserResult
            UserResult userresult;
            if (findtheUser != null)
            {
                // Skapa ett UserResult med hjälp av UserResultFactory
                userresult = factory.CreateUserResult(findtheUser, newResult);

                if (userresult != null)
                {
                    findtheUser.UserResults.Add(userresult);
                    await genericUserManager.CompleteAsync();
                }

            }
      
        }
    }
}