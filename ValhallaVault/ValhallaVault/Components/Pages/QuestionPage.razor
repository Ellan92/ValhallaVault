@page "/QuestionPage/{chosenSegment:int}"
@using ValhallaVault.Models
@using ValhallaVault.Models.ViewModels
@using ValhallaVault.Data
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Identity
@inject ValhallaVault.Managers.QuestionManager questionManager
@inject NavigationManager Navigation
@inject ValhallaVault.Managers.GenericManager<SegmentModel> genericManager
@inject ValhallaVault.Managers.GenericManager<ResultModel> genericResultManager
@inject ValhallaVault.Managers.GenericManager<ApplicationUser> genericUserManager
@inject ValhallaVault.Managers.SubcategoryManager subcategoryManager
@inject AuthenticationStateProvider AuthenticationProvider
@inject ValhallaVault.Managers.UserManager usermanager
@inject ValhallaVault.Managers.Factory factory
@inject SignInManager<ApplicationUser> SignInManager
@rendermode InteractiveServer

<style>
    a.pointer 
    {
        cursor: pointer; /* Ange pekare som muspekare */
    }

    .green-text
    {
        color: green;
        opacity: .7;
    }

    .red-text {
        color: red;
        opacity: .7;
    }

</style>

<div class="container">
    <div class="row">
        <div class="col-md-12">
            <h3 class="mt-3">Frågor för denna subkategori</h3>
            <p><stronger>Återstående frågor: @Questions.Count </stronger></p>
            <!-- Observarade frågor -->
            @if (Questions != null && Questions.Any())
            {
                @foreach (var question in Questions)
                {
                    <div class="card mt-3">
                        <div class="card-body">
                            <h4 class="card-title">@question.Question</h4>
                            <ul class="list-group"> <!-- list-group för alla frågor, vare sig de är besvarade eller inte. -->
                                @if (question.Options != null && question.Options.Count > 0 && question.IsAnswered==false)
                                {
                                    @foreach (var option in question.Options)
                                    {
                                        <li class="list-group-item">
                                            <!-- När användaren klickar på ett option, skicka med både question och option -->
                                            <a class="pointer" @onclick="(() => HandleOptionClick(question, option))">@option</a>
                                           
                                        </li>
                                    }
                                }

                            </ul>
                        </div>
                    </div>
                }
            }

            <button @onclick="SubmitQuiz">Lämna in</button>
            @if (MessageIsVisible==true)
            {
                <h6>Vänligen svara på alla frågor innan du lämnar in.</h6>
            }
            <a href="@($"SegmentPage/{chosenSegment}")" class="btn btn-primary mt-3">Tillbaka</a>

        </div>
    </div>
</div>



@code {
    [Parameter]
    public int chosenSegment { get; set; }

    private bool MessageIsVisible = false;

    public string? UserName { get; set; }

    public SegmentModel? ChosenSegment { get; set; }

    public List<SubcategoryModel> Subcategories { get; set; } = new();

    public int Points = 0;

    public int NumberOfQuestions = 0;

    public List<QuestionViewModel> Questions { get; set; } = new();

    public List<QuestionViewModel> AnsweredQuestions { get; set; } = new();

    public List<SolutionModel> Solutions { get; set; } = new();

    private ApplicationUser? signedIn; // representerar den inloggade användaren
    private AuthenticationState? State; // representerar autentiseringsstatusen för användaren


    protected override async Task OnInitializedAsync()
    {
        var segment = await genericManager.GetByIdAsync(chosenSegment);
        if (segment != null)
        {
            ChosenSegment = segment;

            var allSubcategories = await subcategoryManager.GetSubcategoriesBySegmentIdAsync(chosenSegment);
            if (allSubcategories != null)
            {
                foreach (var subcategory in allSubcategories)
                {
                    Subcategories.Add(subcategory);  // skapa listan med subkategorier
                }
                if (Subcategories.Count>0)
                {
                    foreach (var sc in Subcategories)   // Hämta alla frågor för varje subkategori
                    {
                        var questionList = await questionManager.GetQuestionsBySubcategoryIdAsync(sc.Id);  // en lista med frågor per subkategori

                        if (questionList != null && questionList.Count > 0) // lägg till alla frågor till en och samma lista (Questions)
                        {
                            foreach (var question in questionList)
                            {
                                QuestionViewModel viewmodelQuestion = factory.CreateQuestionViewModel(question); // Gör varje QuestionModel till en QuestionViewModel
                                Questions.Add(viewmodelQuestion);
                            }
                        }
                    }
                }
                NumberOfQuestions = Questions.Count;
            }
        }
    }

    private void SubmitQuiz()
    {
        int answeredQuestions = AnsweredQuestions.Count;
        if (answeredQuestions < NumberOfQuestions)
        {
            MessageIsVisible = true; // visa meddelandet om att alla frågor måste besvaras. 
        }

    }

    private async Task HandleOptionClick(QuestionViewModel question, string chosenOption) // Metod för att utvärdera valt svarsalternativ
    {

        question.IsAnswered = true;
        Questions.Remove(question);
        AnsweredQuestions.Add(question);

        var solutionToQuestion = await questionManager.GetSolutionByQuestionId(question.Id);  // Hämta rätt svar
    
        if (solutionToQuestion!=null)
        {
            Solutions.Add(solutionToQuestion);
            string solution = solutionToQuestion.CorrectAnswer;  // Omvandla rätt svar till en sträng
            bool isCorrectAnswer = chosenOption.Equals(solutionToQuestion.CorrectAnswer);  // Jämför strängen med användarens svar

            ResultModel newResult = null;   // Skapa ett resultat
            if (isCorrectAnswer)
            {
                question.IsCorrectAnswer = true;
                Points++; // lägg till ett poäng
                QuestionModel questionModel = factory.CreateQuestionModel(question);   // Omvandla questionviewmodel till vanlig model
                newResult = factory.CreateCorrectResult(chosenOption, true, questionModel, question.Id);

                ResultViewModel resultviewmodel = factory.CreateResultViewModel(newResult);
           
            }
            else if (!isCorrectAnswer)
            {
                question.IsCorrectAnswer = false;
                StateHasChanged();
                if (Points>0)
                {
                    Points--; // dra bara bort poäng om användaren har minst 1 poäng. 
                }
                QuestionModel questionModel = factory.CreateQuestionModel(question);
                newResult = factory.CreateWrongResult(chosenOption, false, questionModel, question.Id);  // Skapa ett felaktigt resultat med hjälp av Factory

                ResultViewModel resultviewmodel = factory.CreateResultViewModel(newResult);

            }
            await genericResultManager.AddAsync(newResult);  // Spara resultatet i databasen
            await genericResultManager.CompleteAsync();

            // Hämta den inloggade usern för att kunna koppla resultatet till rätt användare
            State = await AuthenticationProvider.GetAuthenticationStateAsync();
            var user = State.User;
            UserName = user.Identity.Name;
            var findtheUser = await usermanager.GetUserByNameAsync(UserName);

            // Skapa ett UserResult
            UserResult userresult;
            if (findtheUser != null)
            {
                // Skapa ett UserResult med hjälp av Factory
                userresult = factory.CreateUserResult(findtheUser, newResult);

                if (userresult != null)
                {
                    findtheUser.UserResults.Add(userresult);
                    await genericUserManager.CompleteAsync();
                }

            }
      
        }
    }
}